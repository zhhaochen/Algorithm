package Theory.theory2_synchronized;

/**
 * 个对象其实有四种锁状态，它们级别由低到高依次是：
 *  - 无锁状态
 *  - 偏向锁状态
 *  - 轻量级锁状态
 *  - 重量级锁状态
 *
 * 锁的升级流程
 * 每一个线程在准备获取共享资源时：
 * 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。
 * 第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。
 * 第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。
 * 第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。
 * 第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。
 * 第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。
 */
public class demo2 {
}
